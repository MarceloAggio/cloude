import streamlit as st
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from scipy import stats
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import silhouette_score
import io
import warnings
from multiprocessing import Pool, cpu_count
from functools import partial

warnings.filterwarnings('ignore')

st.set_page_config(
    page_title="Analisador de Alertas - Completo",
    page_icon="üö®",
    layout="wide",
    initial_sidebar_state="expanded"
)

def classify_alert_pattern(alert_data, isolation_threshold_days=7, min_occurrences=3, low_freq_threshold=0.05):
    """
    Classifica um alerta como isolado ou cont√≠nuo com m√∫ltiplos crit√©rios adicionais.
    """
    n = len(alert_data)
    if n == 0:
        return {
            'pattern': 'isolated',
            'reason': 'Sem ocorr√™ncias',
            'occurrences': 0,
            'max_interval_days': None,
            'avg_interval_days': None
        }
    
    alert_data = alert_data.sort_values('created_on')
    intervals = alert_data['created_on'].diff().dt.total_seconds() / 86400  # em dias
    intervals = intervals.dropna()
    
    if len(intervals) == 0:
        return {
            'pattern': 'isolated',
            'reason': 'Apenas uma ocorr√™ncia',
            'occurrences': n,
            'max_interval_days': None,
            'avg_interval_days': None
        }
    
    max_interval = intervals.max()
    avg_interval = intervals.mean()
    variability = intervals.std() / avg_interval if avg_interval > 0 else 0
    
    total_days = (alert_data['created_on'].max() - alert_data['created_on'].min()).days + 1
    freq_per_day = n / total_days if total_days > 0 else 0
    
    # Crit√©rio 1: poucas ocorr√™ncias
    if n < min_occurrences:
        return {
            'pattern': 'isolated',
            'reason': f'Poucas ocorr√™ncias ({n})',
            'occurrences': n,
            'max_interval_days': max_interval,
            'avg_interval_days': avg_interval
        }
    
    # Crit√©rio 2: gaps muito grandes
    if avg_interval > isolation_threshold_days or max_interval > isolation_threshold_days * 3:
        return {
            'pattern': 'isolated',
            'reason': f'Ocorr√™ncias muito espa√ßadas (m√©dia {avg_interval:.1f} dias, m√°x {max_interval:.1f})',
            'occurrences': n,
            'max_interval_days': max_interval,
            'avg_interval_days': avg_interval
        }
    
    # Crit√©rio 3: baixa frequ√™ncia m√©dia
    if freq_per_day < low_freq_threshold:
        return {
            'pattern': 'isolated',
            'reason': f'Baixa frequ√™ncia ({freq_per_day:.3f}/dia)',
            'occurrences': n,
            'max_interval_days': max_interval,
            'avg_interval_days': avg_interval
        }
    
    # Crit√©rio 4: alta irregularidade
    if variability > 1.5:
        return {
            'pattern': 'isolated',
            'reason': f'Alta variabilidade (CV={variability:.2f})',
            'occurrences': n,
            'max_interval_days': max_interval,
            'avg_interval_days': avg_interval
        }
    
    # Crit√©rio 5: concentra√ß√£o em janela curta
    active_days = alert_data['created_on'].dt.date.nunique()
    if active_days <= 2 and total_days > 30:
        return {
            'pattern': 'isolated',
            'reason': f'Concentrado em apenas {active_days} dias dentro de {total_days} dias',
            'occurrences': n,
            'max_interval_days': max_interval,
            'avg_interval_days': avg_interval
        }
    
    # Crit√©rio 6: desaparecimento ap√≥s certo ponto
    if (alert_data['created_on'].max() < alert_data['created_on'].min() + pd.Timedelta(days=total_days*0.2)):
        return {
            'pattern': 'isolated',
            'reason': 'Ocorr√™ncias apenas no in√≠cio da janela de an√°lise',
            'occurrences': n,
            'max_interval_days': max_interval,
            'avg_interval_days': avg_interval
        }
    
    return {
        'pattern': 'continuous',
        'reason': 'Padr√£o consistente de ocorr√™ncias',
        'occurrences': n,
        'max_interval_days': max_interval,
        'avg_interval_days': avg_interval
    }

def process_single_alert(alert_id, df_original, isolation_threshold_days=7, min_occurrences=2):
    try:
        df_alert = df_original[df_original['u_alert_id'] == alert_id].copy()
        if len(df_alert) < 1:  # Mudado de 2 para 1 para incluir alertas √∫nicos
            return None
        
        # Classifica√ß√£o de padr√£o (isolado vs cont√≠nuo)
        pattern_info = classify_alert_pattern(df_alert, isolation_threshold_days, min_occurrences)
        
        df_alert['hour'] = df_alert['created_on'].dt.hour
        df_alert['day_of_week'] = df_alert['created_on'].dt.dayofweek
        df_alert['is_weekend'] = df_alert['day_of_week'].isin([5, 6])
        df_alert['is_business_hours'] = (df_alert['hour'] >= 9) & (df_alert['hour'] <= 17)
        df_alert = df_alert.sort_values('created_on')
        intervals_hours = df_alert['created_on'].diff().dt.total_seconds() / 3600
        intervals_hours = intervals_hours.dropna()
        
        period_days = (df_alert['created_on'].max() - df_alert['created_on'].min()).days + 1
        
        metrics = {
            'alert_id': alert_id,
            'pattern_type': pattern_info['pattern'],
            'pattern_reason': pattern_info['reason'],
            'total_ocorrencias': len(df_alert),
            'periodo_dias': period_days,
            'freq_dia': len(df_alert) / period_days if period_days > 0 else 0,
            'freq_semana': (len(df_alert) / period_days * 7) if period_days > 0 else 0,
            'freq_mes': (len(df_alert) / period_days * 30) if period_days > 0 else 0,
            'intervalo_medio_h': intervals_hours.mean() if len(intervals_hours) > 0 else None,
            'intervalo_mediano_h': intervals_hours.median() if len(intervals_hours) > 0 else None,
            'intervalo_std_h': intervals_hours.std() if len(intervals_hours) > 0 else None,
            'intervalo_min_h': intervals_hours.min() if len(intervals_hours) > 0 else None,
            'intervalo_max_h': intervals_hours.max() if len(intervals_hours) > 0 else None,
            'max_intervalo_dias': pattern_info['max_interval_days'],
            'hora_pico': df_alert['hour'].mode().iloc[0] if len(df_alert['hour'].mode()) > 0 else 12,
            'pct_fins_semana': df_alert['is_weekend'].mean() * 100,
            'pct_horario_comercial': df_alert['is_business_hours'].mean() * 100,
            'variabilidade_intervalo': intervals_hours.std() / intervals_hours.mean() if len(intervals_hours) > 0 and intervals_hours.mean() > 0 else 0,
            'primeiro_alerta': df_alert['created_on'].min(),
            'ultimo_alerta': df_alert['created_on'].max()
        }
        return metrics
    except Exception as e:
        return None

def process_alert_chunk(alert_ids, df_original, isolation_threshold_days=7, min_occurrences=2):
    return [metrics for alert_id in alert_ids 
            if (metrics := process_single_alert(alert_id, df_original, isolation_threshold_days, min_occurrences))]

class StreamlitAlertAnalyzer:
    def __init__(self):
        self.df_original = None
        self.df_all_alerts = None
        self.df = None
        self.dates = None
        self.alert_id = None
        self.isolation_threshold_days = 7
        self.min_occurrences = 2

    def load_data(self, uploaded_file):
        try:
            df_raw = pd.read_csv(uploaded_file)
            st.success(f"‚úÖ Arquivo carregado com {len(df_raw)} registros")
            with st.expander("üìã Informa√ß√µes do Dataset"):
                st.write(f"**Colunas:** {list(df_raw.columns)}")
                st.write(f"**Shape:** {df_raw.shape}")
                st.dataframe(df_raw.head())
            if 'created_on' not in df_raw.columns or 'u_alert_id' not in df_raw.columns:
                st.error("‚ùå Colunas 'created_on' e 'u_alert_id' s√£o obrigat√≥rias!")
                return False
            df_raw['created_on'] = pd.to_datetime(df_raw['created_on'])
            df_raw = df_raw.dropna(subset=['created_on'])
            df_raw = df_raw.sort_values(['u_alert_id', 'created_on']).reset_index(drop=True)
            self.df_original = df_raw
            st.sidebar.write(f"**IDs dispon√≠veis:** {len(df_raw['u_alert_id'].unique())}")
            return True
        except Exception as e:
            st.error(f"‚ùå Erro ao carregar dados: {e}")
            return False

    def prepare_individual_analysis(self, alert_id):
        df_filtered = self.df_original[self.df_original['u_alert_id'] == alert_id].copy()
        if len(df_filtered) == 0:
            return False

        df_filtered['date'] = df_filtered['created_on'].dt.date
        df_filtered['hour'] = df_filtered['created_on'].dt.hour
        df_filtered['day_of_week'] = df_filtered['created_on'].dt.dayofweek
        df_filtered['day_name'] = df_filtered['created_on'].dt.day_name()
        df_filtered['month'] = df_filtered['created_on'].dt.month
        df_filtered['month_name'] = df_filtered['created_on'].dt.month_name()
        df_filtered['is_weekend'] = df_filtered['day_of_week'].isin([5, 6])
        df_filtered['is_business_hours'] = (df_filtered['hour'] >= 9) & (df_filtered['hour'] <= 17)
        df_filtered['time_diff_hours'] = df_filtered['created_on'].diff().dt.total_seconds() / 3600
        df_filtered['time_diff_days'] = df_filtered['created_on'].diff().dt.total_seconds() / 86400

        # Marca alertas isolados
        isolation_threshold_days = self.isolation_threshold_days
        df_filtered['isolated'] = (df_filtered['time_diff_days'] > isolation_threshold_days) | (df_filtered['time_diff_days'].isna())
        df_filtered.loc[df_filtered.index[0], 'isolated'] = True  # garante que o primeiro alerta seja isolado


        self.df = df_filtered
        self.dates = df_filtered['created_on']
        self.alert_id = alert_id
        return True


    def prepare_global_analysis(self, use_multiprocessing=True, isolation_threshold_days=7, min_occurrences=2):
        st.header("üåç An√°lise Global de Todos os Alertas")
        self.isolation_threshold_days = isolation_threshold_days
        self.min_occurrences = min_occurrences
        
        unique_ids = self.df_original['u_alert_id'].unique()
        total_ids = len(unique_ids)
        st.info(f"üìä Processando {total_ids} Alert IDs...")
        alert_metrics = []
        
        if use_multiprocessing:
            n_processes = min(cpu_count(), total_ids)
            st.write(f"üöÄ Usando {n_processes} processos paralelos")
            chunk_size = max(1, total_ids // n_processes)
            id_chunks = [unique_ids[i:i + chunk_size] for i in range(0, total_ids, chunk_size)]
            progress_bar = st.progress(0)
            status_text = st.empty()
            process_func = partial(process_alert_chunk, 
                                  df_original=self.df_original,
                                  isolation_threshold_days=isolation_threshold_days,
                                  min_occurrences=min_occurrences)
            try:
                with Pool(processes=n_processes) as pool:
                    results = pool.map(process_func, id_chunks)
                    for result in results:
                        alert_metrics.extend(result)
                    progress_bar.progress(1.0)
                    status_text.success(f"‚úÖ Processamento conclu√≠do! {len(alert_metrics)} alertas analisados")
            except Exception as e:
                st.error(f"‚ùå Erro no multiprocessing: {e}")
                st.warning("‚ö†Ô∏è Tentando processamento sequencial...")
                use_multiprocessing = False
                alert_metrics = []
        
        if not use_multiprocessing or len(alert_metrics) == 0:
            alert_metrics = []
            progress_bar = st.progress(0)
            for i, alert_id in enumerate(unique_ids):
                progress_bar.progress((i + 1) / total_ids)
                metrics = process_single_alert(alert_id, self.df_original, 
                                              isolation_threshold_days, min_occurrences)
                if metrics:
                    alert_metrics.append(metrics)
        
        if 'progress_bar' in locals():
            progress_bar.empty()
        
        self.df_all_alerts = pd.DataFrame(alert_metrics)
        
        # Estat√≠sticas de padr√µes
        isolated_count = len(self.df_all_alerts[self.df_all_alerts['pattern_type'] == 'isolated'])
        continuous_count = len(self.df_all_alerts[self.df_all_alerts['pattern_type'] == 'continuous'])
        
        st.subheader("üìä Estat√≠sticas Globais")
        col1, col2, col3, col4, col5, col6 = st.columns(6)
        with col1:
            st.metric("üî¢ Total de Alert IDs", len(unique_ids))
        with col2:
            st.metric("üìà IDs com Dados", len(self.df_all_alerts))
        with col3:
            st.metric("üö® Total de Alertas", self.df_original.shape[0])
        with col4:
            period_total = (self.df_original['created_on'].max() - self.df_original['created_on'].min()).days + 1
            st.metric("üìÖ Per√≠odo (dias)", period_total)
        with col5:
            st.metric("üî¥ Alertas Isolados", isolated_count)
        with col6:
            st.metric("üü¢ Alertas Cont√≠nuos", continuous_count)
        
        return len(self.df_all_alerts) > 0

    def show_isolated_vs_continuous_analysis(self):
        """Nova fun√ß√£o para an√°lise de alertas isolados vs cont√≠nuos"""
        st.header("üîç An√°lise de Alertas Isolados vs Cont√≠nuos")
        
        # Separar alertas
        df_isolated = self.df_all_alerts[self.df_all_alerts['pattern_type'] == 'isolated']
        df_continuous = self.df_all_alerts[self.df_all_alerts['pattern_type'] == 'continuous']
        
        # Visualiza√ß√£o geral
        col1, col2 = st.columns(2)
        
        with col1:
            # Gr√°fico de pizza
            pattern_dist = self.df_all_alerts['pattern_type'].value_counts()
            fig_pie = px.pie(
                values=pattern_dist.values,
                names=pattern_dist.index,
                title="üìä Distribui√ß√£o de Padr√µes de Alerta",
                color_discrete_map={'isolated': '#ff4444', 'continuous': '#44ff44'}
            )
            st.plotly_chart(fig_pie, use_container_width=True)
        
        with col2:
            # Estat√≠sticas comparativas
            st.subheader("üìà Compara√ß√£o de M√©tricas")
            comparison_data = pd.DataFrame({
                'M√©trica': ['Qtd Alertas', 'M√©dia Ocorr√™ncias', 'Mediana Ocorr√™ncias', 
                           'M√©dia Freq/Dia', 'M√©dia Intervalo (h)'],
                'Isolados': [
                    len(df_isolated),
                    df_isolated['total_ocorrencias'].mean() if len(df_isolated) > 0 else 0,
                    df_isolated['total_ocorrencias'].median() if len(df_isolated) > 0 else 0,
                    df_isolated['freq_dia'].mean() if len(df_isolated) > 0 else 0,
                    df_isolated['intervalo_medio_h'].mean() if len(df_isolated) > 0 else 0
                ],
                'Cont√≠nuos': [
                    len(df_continuous),
                    df_continuous['total_ocorrencias'].mean() if len(df_continuous) > 0 else 0,
                    df_continuous['total_ocorrencias'].median() if len(df_continuous) > 0 else 0,
                    df_continuous['freq_dia'].mean() if len(df_continuous) > 0 else 0,
                    df_continuous['intervalo_medio_h'].mean() if len(df_continuous) > 0 else 0
                ]
            })
            comparison_data = comparison_data.round(2)
            st.dataframe(comparison_data, use_container_width=True)
        
        # Tabs para detalhes
        tab1, tab2, tab3 = st.tabs(["üî¥ Alertas Isolados", "üü¢ Alertas Cont√≠nuos", "üìä An√°lise Comparativa"])
        
        with tab1:
            st.subheader(f"üî¥ Alertas Isolados ({len(df_isolated)} alertas)")
            
            if len(df_isolated) > 0:
                fig_iso = px.line(df_isolated, x='created_on', y='time_diff_days', title="‚è≥ Intervalos entre Alertas Isolados (dias)")
                st.plotly_chart(fig_iso, use_container_width=True)
                # Raz√µes para isolamento
                st.write("**üìù Raz√µes para Classifica√ß√£o como Isolado:**")
                reason_counts = df_isolated['pattern_reason'].value_counts()
                for reason, count in reason_counts.items():
                    st.write(f"‚Ä¢ {reason}: {count} alertas")
                
                # Top alertas isolados
                st.write("**üîù Top 10 Alertas Isolados (por ocorr√™ncias):**")
                top_isolated = df_isolated.nlargest(10, 'total_ocorrencias')[
                    ['alert_id', 'total_ocorrencias', 'max_intervalo_dias', 'pattern_reason']
                ]
                top_isolated.columns = ['Alert ID', 'Ocorr√™ncias', 'Max Intervalo (dias)', 'Raz√£o']
                st.dataframe(top_isolated, use_container_width=True)
                
                # Lista completa expans√≠vel
                with st.expander("üìã Ver todos os alertas isolados"):
                    isolated_list = df_isolated[['alert_id', 'total_ocorrencias', 
                                                'max_intervalo_dias', 'pattern_reason']].copy()
                    isolated_list.columns = ['Alert ID', 'Ocorr√™ncias', 'Max Intervalo (dias)', 'Raz√£o']
                    st.dataframe(isolated_list, use_container_width=True)
            else:
                st.info("Nenhum alerta isolado encontrado com os crit√©rios atuais.")
        
        with tab2:
            st.subheader(f"üü¢ Alertas Cont√≠nuos ({len(df_continuous)} alertas)")
            
            if len(df_continuous) > 0:
                # Top alertas cont√≠nuos
                st.write("**üîù Top 10 Alertas Cont√≠nuos (maior frequ√™ncia):**")
                top_continuous = df_continuous.nlargest(10, 'freq_dia')[
                    ['alert_id', 'total_ocorrencias', 'freq_dia', 'intervalo_medio_h']
                ]
                top_continuous.columns = ['Alert ID', 'Total Ocorr√™ncias', 'Freq/Dia', 'Intervalo M√©dio (h)']
                st.dataframe(top_continuous, use_container_width=True)
                
                # Distribui√ß√£o de frequ√™ncias
                col1, col2 = st.columns(2)
                with col1:
                    fig_freq = px.histogram(
                        df_continuous, 
                        x='freq_dia',
                        title="üìä Distribui√ß√£o de Frequ√™ncia (Cont√≠nuos)",
                        labels={'freq_dia': 'Alertas por Dia', 'count': 'Quantidade'}
                    )
                    st.plotly_chart(fig_freq, use_container_width=True)
                
                with col2:
                    fig_int = px.histogram(
                        df_continuous,
                        x='intervalo_medio_h',
                        title="‚è±Ô∏è Distribui√ß√£o de Intervalos (Cont√≠nuos)",
                        labels={'intervalo_medio_h': 'Intervalo M√©dio (h)', 'count': 'Quantidade'}
                    )
                    st.plotly_chart(fig_int, use_container_width=True)
                
                # Lista completa expans√≠vel
                with st.expander("üìã Ver todos os alertas cont√≠nuos"):
                    continuous_list = df_continuous[['alert_id', 'total_ocorrencias', 
                                                    'freq_dia', 'intervalo_medio_h']].copy()
                    continuous_list.columns = ['Alert ID', 'Ocorr√™ncias', 'Freq/Dia', 'Intervalo M√©dio (h)']
                    st.dataframe(continuous_list, use_container_width=True)
            else:
                st.info("Nenhum alerta cont√≠nuo encontrado com os crit√©rios atuais.")
        
        with tab3:
            st.subheader("üìä An√°lise Comparativa Detalhada")
            
            # Scatter plot comparativo
            fig_scatter = px.scatter(
                self.df_all_alerts,
                x='total_ocorrencias',
                y='intervalo_medio_h',
                color='pattern_type',
                title="üéØ Ocorr√™ncias vs Intervalo M√©dio",
                labels={
                    'total_ocorrencias': 'Total de Ocorr√™ncias',
                    'intervalo_medio_h': 'Intervalo M√©dio (horas)',
                    'pattern_type': 'Tipo de Padr√£o'
                },
                hover_data=['alert_id'],
                color_discrete_map={'isolated': '#ff4444', 'continuous': '#44ff44'}
            )
            st.plotly_chart(fig_scatter, use_container_width=True)
            
            # Box plots comparativos
            col1, col2 = st.columns(2)
            
            with col1:
                fig_box_occ = px.box(
                    self.df_all_alerts,
                    x='pattern_type',
                    y='total_ocorrencias',
                    title="üì¶ Distribui√ß√£o de Ocorr√™ncias",
                    labels={
                        'pattern_type': 'Tipo de Padr√£o',
                        'total_ocorrencias': 'Total de Ocorr√™ncias'
                    },
                    color='pattern_type',
                    color_discrete_map={'isolated': '#ff4444', 'continuous': '#44ff44'}
                )
                st.plotly_chart(fig_box_occ, use_container_width=True)
            
            with col2:
                fig_box_freq = px.box(
                    self.df_all_alerts,
                    x='pattern_type',
                    y='freq_dia',
                    title="üì¶ Distribui√ß√£o de Frequ√™ncia Di√°ria",
                    labels={
                        'pattern_type': 'Tipo de Padr√£o',
                        'freq_dia': 'Frequ√™ncia por Dia'
                    },
                    color='pattern_type',
                    color_discrete_map={'isolated': '#ff4444', 'continuous': '#44ff44'}
                )
                st.plotly_chart(fig_box_freq, use_container_width=True)
            
            # Recomenda√ß√µes
            st.subheader("üí° Recomenda√ß√µes de Tratamento")
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.write("**üî¥ Para Alertas Isolados:**")
                st.write("‚Ä¢ Considerar desativa√ß√£o ou revis√£o de configura√ß√£o")
                st.write("‚Ä¢ Verificar se s√£o falsos positivos")
                st.write("‚Ä¢ Analisar contexto espec√≠fico das ocorr√™ncias")
                st.write("‚Ä¢ Avaliar consolida√ß√£o com outros alertas similares")
            
            with col2:
                st.write("**üü¢ Para Alertas Cont√≠nuos:**")
                st.write("‚Ä¢ Priorizar automa√ß√£o de resposta")
                st.write("‚Ä¢ Implementar supress√£o inteligente")
                st.write("‚Ä¢ Criar runbooks espec√≠ficos")
                st.write("‚Ä¢ Considerar ajuste de thresholds")

    def show_global_overview(self, filter_isolated=False):
        st.subheader("üìà Vis√£o Geral dos Alertas")
        
        # Aplicar filtro se necess√°rio
        df_to_analyze = self.df_all_alerts
        if filter_isolated:
            df_to_analyze = self.df_all_alerts[self.df_all_alerts['pattern_type'] == 'continuous']
            st.info(f"üîç Mostrando apenas alertas cont√≠nuos ({len(df_to_analyze)} de {len(self.df_all_alerts)})")
        
        col1, col2 = st.columns(2)
        with col1:
            st.write("**üî• Top 10 Alertas Mais Frequentes**")
            top_frequent = df_to_analyze.nlargest(10, 'total_ocorrencias')[['alert_id', 'total_ocorrencias', 'freq_dia', 'pattern_type']]
            top_frequent.columns = ['Alert ID', 'Total Ocorr√™ncias', 'Frequ√™ncia/Dia', 'Tipo']
            st.dataframe(top_frequent, use_container_width=True)
        with col2:
            st.write("**‚ö° Top 10 Alertas Mais R√°pidos (Menor Intervalo)**")
            df_with_intervals = df_to_analyze.dropna(subset=['intervalo_medio_h'])
            if len(df_with_intervals) > 0:
                top_fast = df_with_intervals.nsmallest(10, 'intervalo_medio_h')[['alert_id', 'intervalo_medio_h', 'total_ocorrencias', 'pattern_type']]
                top_fast.columns = ['Alert ID', 'Intervalo M√©dio (h)', 'Total Ocorr√™ncias', 'Tipo']
                st.dataframe(top_fast, use_container_width=True)
            else:
                st.info("Sem dados de intervalo dispon√≠veis")
        
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            fig_freq = px.histogram(df_to_analyze, x='freq_dia', title="üìä Distribui√ß√£o de Frequ√™ncia (alertas/dia)",
                                   labels={'freq_dia': 'Alertas por Dia', 'count': 'Quantidade de Alert IDs'})
            st.plotly_chart(fig_freq, use_container_width=True)
        with col2:
            fig_int = px.histogram(df_to_analyze, x='freq_semana', title="üìä Distribui√ß√£o de Frequ√™ncia (alertas/semana)",
                                  labels={'freq_semana': 'Alertas por semana', 'count': 'Quantidade de Alert IDs'})
            st.plotly_chart(fig_int, use_container_width=True)
        with col3:
            fig_int = px.histogram(df_to_analyze, x='freq_mes', title="üìä Distribui√ß√£o de Frequ√™ncia (alertas/mes)",
                                  labels={'freq_mes': 'Alertas por mes', 'count': 'Quantidade de Alert IDs'})
            st.plotly_chart(fig_int, use_container_width=True)
        with col4:
            df_with_intervals = df_to_analyze.dropna(subset=['intervalo_medio_h'])
            if len(df_with_intervals) > 0:
                fig_int = px.histogram(df_with_intervals, x='intervalo_medio_h', title="‚è±Ô∏è Distribui√ß√£o de Intervalos M√©dios",
                                      labels={'intervalo_medio_h': 'Intervalo M√©dio (horas)', 'count': 'Quantidade de Alert IDs'})
                st.plotly_chart(fig_int, use_container_width=True)

    def perform_clustering_analysis(self, use_only_continuous=True):
        st.subheader("üéØ Agrupamento de Alertas por Perfil de Comportamento")
        
        # Filtrar apenas cont√≠nuos se solicitado
        df_for_clustering = self.df_all_alerts
        if use_only_continuous:
            df_for_clustering = self.df_all_alerts[self.df_all_alerts['pattern_type'] == 'continuous']
            st.info(f"üîç Usando apenas alertas cont√≠nuos para clustering ({len(df_for_clustering)} alertas)")
        
        if len(df_for_clustering) < 2:
            st.warning("‚ö†Ô∏è Dados insuficientes para clustering")
            return None
        
        features = [
            'freq_dia', 'intervalo_medio_h', 'intervalo_std_h',
            'hora_pico', 'pct_fins_semana', 'pct_horario_comercial', 'variabilidade_intervalo'
        ]
        X = df_for_clustering[features].fillna(0)
        scaler = StandardScaler()
        X_scaled = scaler.fit_transform(X)
        
        st.write("**üîç Determinando N√∫mero √ìtimo de Clusters...**")
        max_clusters = min(10, len(X) - 1)
        silhouette_scores = []
        inertias = []
        
        for k in range(2, max_clusters + 1):
            kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
            cluster_labels = kmeans.fit_predict(X_scaled)
            silhouette_scores.append(silhouette_score(X_scaled, cluster_labels))
            inertias.append(kmeans.inertia_)
        
        optimal_k = range(2, max_clusters + 1)[np.argmax(silhouette_scores)]
        
        col1, col2 = st.columns(2)
        with col1:
            st.metric("üéØ N√∫mero √ìtimo de Clusters", optimal_k)
        with col2:
            st.metric("üìä Silhouette Score", f"{max(silhouette_scores):.3f}")
        
        kmeans_final = KMeans(n_clusters=optimal_k, random_state=42, n_init=10)
        clusters = kmeans_final.fit_predict(X_scaled)
        self.df_all_alerts['cluster'] = clusters
        col1, col2 = st.columns(2)
        with col1:
            fig_scatter = px.scatter(
                self.df_all_alerts,
                x='freq_dia',
                y='intervalo_medio_h',
                color='cluster',
                size='total_ocorrencias',
                hover_data=['alert_id'],
                title="üé® Clusters: Frequ√™ncia vs Intervalo M√©dio"
            )
            st.plotly_chart(fig_scatter, use_container_width=True)
        with col2:
            cluster_dist = self.df_all_alerts['cluster'].value_counts().sort_index()
            fig_dist = px.bar(
                x=cluster_dist.index,
                y=cluster_dist.values,
                title="üìä Distribui√ß√£o de Alertas por Cluster",
                labels={'x': 'Cluster', 'y': 'Quantidade de Alert IDs'}
            )
            st.plotly_chart(fig_dist, use_container_width=True)
        return optimal_k

    def show_cluster_profiles(self, n_clusters):
        st.subheader("üë• Perfis dos Clusters")
        cluster_profiles = self.df_all_alerts.groupby('cluster').agg({
            'total_ocorrencias': ['mean', 'std', 'count'],
            'freq_dia': ['mean', 'std'],
            'intervalo_medio_h': ['mean', 'std'],
            'hora_pico': 'mean',
            'pct_fins_semana': 'mean',
            'pct_horario_comercial': 'mean',
            'variabilidade_intervalo': 'mean'
        }).round(2)
        cluster_tabs = st.tabs([f"Cluster {i}" for i in range(n_clusters)])
        for i in range(n_clusters):
            with cluster_tabs[i]:
                cluster_data = self.df_all_alerts[self.df_all_alerts['cluster'] == i]
                col1, col2, col3, col4 = st.columns(4)
                with col1:
                    st.metric("üìä Quantidade de Alertas", len(cluster_data))
                with col2:
                    avg_freq = cluster_data['freq_dia'].mean()
                    st.metric("üìà Freq. M√©dia/Dia", f"{avg_freq:.2f}")
                with col3:
                    avg_interval = cluster_data['intervalo_medio_h'].mean()
                    st.metric("‚è±Ô∏è Intervalo M√©dio (h)", f"{avg_interval:.2f}")
                with col4:
                    avg_hour = cluster_data['hora_pico'].mean()
                    st.metric("üïê Hora Pico M√©dia", f"{avg_hour:.0f}:00")
                st.write("**üéØ Caracter√≠sticas do Cluster:**")
                weekend_pct = cluster_data['pct_fins_semana'].mean()
                business_pct = cluster_data['pct_horario_comercial'].mean()
                variability = cluster_data['variabilidade_intervalo'].mean()
                characteristics = []
                if avg_freq > self.df_all_alerts['freq_dia'].median():
                    characteristics.append("üî• **Alta frequ√™ncia**")
                else:
                    characteristics.append("üêå **Baixa frequ√™ncia**")
                if avg_interval < self.df_all_alerts['intervalo_medio_h'].median():
                    characteristics.append("‚ö° **Intervalos curtos**")
                else:
                    characteristics.append("‚è≥ **Intervalos longos**")
                if weekend_pct > 30:
                    characteristics.append("üóìÔ∏è **Ativo nos fins de semana**")
                if business_pct > 70:
                    characteristics.append("üè¢ **Predominantemente em hor√°rio comercial**")
                elif business_pct < 30:
                    characteristics.append("üåô **Predominantemente fora do hor√°rio comercial**")
                if variability > self.df_all_alerts['variabilidade_intervalo'].median():
                    characteristics.append("üìä **Padr√£o irregular**")
                else:
                    characteristics.append("üìà **Padr√£o regular**")
                for char in characteristics:
                    st.write(f"‚Ä¢ {char}")
                with st.expander(f"üìã Alertas no Cluster {i}"):
                    cluster_alerts = cluster_data[['alert_id', 'total_ocorrencias', 'freq_dia', 'intervalo_medio_h']].copy()
                    cluster_alerts.columns = ['Alert ID', 'Total Ocorr√™ncias', 'Freq/Dia', 'Intervalo M√©dio (h)']
                    st.dataframe(cluster_alerts, use_container_width=True)

    def show_cluster_recommendations(self):
        st.subheader("üí° Recomenda√ß√µes por Cluster")
        for cluster_id in sorted(self.df_all_alerts['cluster'].unique()):
            cluster_data = self.df_all_alerts[self.df_all_alerts['cluster'] == cluster_id]
            avg_freq = cluster_data['freq_dia'].mean()
            avg_interval = cluster_data['intervalo_medio_h'].mean()
            weekend_pct = cluster_data['pct_fins_semana'].mean()
            business_pct = cluster_data['pct_horario_comercial'].mean()
            with st.expander(f"üéØ Recomenda√ß√µes para Cluster {cluster_id} ({len(cluster_data)} alertas)"):
                recommendations = []
                if avg_freq > 5:
                    recommendations.append("üö® **Prioridade Alta**: Alertas muito frequentes - investigar causa raiz")
                    recommendations.append("üîß **A√ß√£o**: Considerar automa√ß√£o de resposta ou ajuste de thresholds")
                if avg_interval < 1:
                    recommendations.append("‚ö° **Rajadas detectadas**: Poss√≠vel tempestade de alertas")
                    recommendations.append("üõ°Ô∏è **A√ß√£o**: Implementar rate limiting ou supress√£o inteligente")
                if weekend_pct > 50:
                    recommendations.append("üóìÔ∏è **Padr√£o de fim de semana**: Alertas ativos nos fins de semana")
                    recommendations.append("üë• **A√ß√£o**: Verificar cobertura de plant√£o")
                if business_pct < 30:
                    recommendations.append("üåô **Padr√£o noturno**: Principalmente fora do hor√°rio comercial")
                    recommendations.append("üîÑ **A√ß√£o**: Considerar processos automatizados noturnos")
                if avg_freq < 0.5:
                    recommendations.append("üìâ **Baixa frequ√™ncia**: Alertas espor√°dicos")
                    recommendations.append("üìä **A√ß√£o**: Revisar relev√¢ncia e configura√ß√£o do alerta")
                for rec in recommendations:
                    st.write(f"‚Ä¢ {rec}")
                if not recommendations:
                    st.write("‚Ä¢ ‚úÖ **Padr√£o normal**: Nenhuma a√ß√£o espec√≠fica recomendada")

    def show_basic_stats(self):
        st.header("üìä Estat√≠sticas B√°sicas")
        total = len(self.df)
        period_days = (self.dates.max() - self.dates.min()).days + 1
        avg_per_day = total / period_days
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("üî• Total de Ocorr√™ncias", total)
        with col2:
            st.metric("üìÖ Per√≠odo (dias)", period_days)
        with col3:
            st.metric("üìà M√©dia/dia", f"{avg_per_day:.2f}")
        with col4:
            last_alert = self.dates.max().strftime("%d/%m %H:%M")
            st.metric("üïê √öltimo Alerta", last_alert)
        intervals = self.df['time_diff_hours'].dropna()
        if len(intervals) > 0:
            st.subheader("‚è±Ô∏è Intervalos Entre Alertas")
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                st.metric("M√©dia (h)", f"{intervals.mean():.2f}")
            with col2:
                st.metric("Mediana (h)", f"{intervals.median():.2f}")
            with col3:
                st.metric("M√≠nimo (h)", f"{intervals.min():.2f}")
            with col4:
                st.metric("M√°ximo (h)", f"{intervals.max():.2f}")

    def show_individual_alert_analysis(self):
        st.header(f"üìå An√°lise Individual do Alert ID: {self.alert_id}")
    
        if self.df is None or len(self.df) == 0:
            st.info("Nenhum dado dispon√≠vel para este alerta.")
            return
    
        # Separar alertas isolados e cont√≠nuos
        df_isolated = self.df[self.df['isolated']]
        df_continuous = self.df[~self.df['isolated']]
    
        tab1, tab2 = st.tabs(["üî¥ Isolados", "üü¢ Cont√≠nuos"])
    
        with tab1:
            st.subheader(f"üî¥ Ocorr√™ncias Isoladas ({len(df_isolated)})")
            if len(df_isolated) > 0:
                st.dataframe(df_isolated[['created_on', 'hour', 'day_name', 'time_diff_hours']], use_container_width=True)
                st.write(f"Percentual de ocorr√™ncias isoladas: {len(df_isolated)/len(self.df)*100:.2f}%")
            else:
                st.info("Nenhuma ocorr√™ncia isolada detectada neste alerta.")
    
        with tab2:
            st.subheader(f"üü¢ Ocorr√™ncias Cont√≠nuas ({len(df_continuous)})")
            if len(df_continuous) > 0:
                st.dataframe(df_continuous[['created_on', 'hour', 'day_name', 'time_diff_hours']], use_container_width=True)
                st.write(f"Percentual de ocorr√™ncias cont√≠nuas: {len(df_continuous)/len(self.df)*100:.2f}%")
            else:
                st.info("Nenhuma ocorr√™ncia cont√≠nua detectada neste alerta.")
    
        # Estat√≠sticas gerais
        st.subheader("üìä Estat√≠sticas Gerais do Alert ID")
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("Total Ocorr√™ncias", len(self.df))
        with col2:
            st.metric("Isolados", len(df_isolated))
        with col3:
            st.metric("Cont√≠nuos", len(df_continuous))
        with col4:
            avg_interval = self.df['time_diff_hours'].dropna().mean() if len(self.df) > 1 else 0
            st.metric("Intervalo M√©dio (h)", f"{avg_interval:.2f}")
    
    


    def show_temporal_patterns(self):
        st.header("‚è∞ Padr√µes Temporais")
        col1, col2 = st.columns(2)
        with col1:
            hourly = self.df['hour'].value_counts().sort_index()
            fig_hour = px.bar(
                x=hourly.index, 
                y=hourly.values,
                title="üìä Distribui√ß√£o por Hora do Dia",
                labels={'x': 'Hora', 'y': 'Quantidade de Alertas'}
            )
            fig_hour.update_layout(showlegend=False)
            st.plotly_chart(fig_hour, use_container_width=True)
            peak_hour = hourly.idxmax()
            quiet_hour = hourly.idxmin()
            st.write(f"üïê **Pico:** {peak_hour:02d}:00 ({hourly[peak_hour]} alertas)")
            st.write(f"üåô **Menor atividade:** {quiet_hour:02d}:00 ({hourly[quiet_hour]} alertas)")
        with col2:
            daily = self.df['day_name'].value_counts()
            days_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
            daily_ordered = daily.reindex(days_order).fillna(0)
            fig_day = px.bar(
                x=daily_ordered.index, 
                y=daily_ordered.values,
                title="üìÖ Distribui√ß√£o por Dia da Semana",
                labels={'x': 'Dia', 'y': 'Quantidade de Alertas'}
            )
            fig_day.update_layout(showlegend=False)
            st.plotly_chart(fig_day, use_container_width=True)
            busiest_day = daily.idxmax()
            st.write(f"üìà **Dia mais ativo:** {busiest_day} ({daily[busiest_day]} alertas)")
        col1, col2 = st.columns(2)
        with col1:
            business = self.df['is_business_hours'].sum()
            non_business = len(self.df) - business
            st.subheader("üè¢ Hor√°rio Comercial (9h-17h)")
            business_data = pd.DataFrame({
                'Per√≠odo': ['Comercial', 'Fora do hor√°rio'],
                'Quantidade': [business, non_business],
                'Porcentagem': [business/len(self.df)*100, non_business/len(self.df)*100]
            })
            fig_business = px.pie(
                business_data, 
                values='Quantidade', 
                names='Per√≠odo',
                title="Distribui√ß√£o por Hor√°rio"
            )
            st.plotly_chart(fig_business, use_container_width=True)
        with col2:
            weekend = self.df['is_weekend'].sum()
            weekday = len(self.df) - weekend
            st.subheader("üóìÔ∏è Fins de Semana vs Dias √öteis")
            weekend_data = pd.DataFrame({
                'Per√≠odo': ['Dias √∫teis', 'Fins de semana'],
                'Quantidade': [weekday, weekend],
                'Porcentagem': [weekday/len(self.df)*100, weekend/len(self.df)*100]
            })
            fig_weekend = px.pie(
                weekend_data, 
                values='Quantidade', 
                names='Per√≠odo',
                title="Distribui√ß√£o Semanal"
            )
            st.plotly_chart(fig_weekend, use_container_width=True)

    def show_burst_analysis(self):
        st.header("üí• An√°lise de Rajadas")
        burst_threshold = st.slider("‚è±Ô∏è Threshold para Rajada (horas)", 0.5, 24.0, 2.0, 0.5)
        intervals = self.df[~self.df['isolated']]['time_diff_hours'].fillna(999)
        bursts, current_burst = [], []
        for i, interval in enumerate(intervals):
            if interval <= burst_threshold and i > 0:
                if not current_burst:
                    current_burst = [i-1, i]
                else:
                    current_burst.append(i)
            else:
                if len(current_burst) >= 2:
                    bursts.append(current_burst)
                current_burst = []
        if len(current_burst) >= 2:
            bursts.append(current_burst)
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("üö® Rajadas Detectadas", len(bursts))
        if bursts:
            burst_sizes = [len(b) for b in bursts]
            with col2:
                st.metric("üìä Tamanho M√©dio", f"{np.mean(burst_sizes):.1f}")
            with col3:
                st.metric("üìà Maior Rajada", f"{max(burst_sizes)} alertas")
            st.subheader("üî• Maiores Rajadas")
            sorted_bursts = sorted(bursts, key=len, reverse=True)[:5]
            burst_data = []
            for i, burst_indices in enumerate(sorted_bursts):
                start_time = self.df.iloc[burst_indices[0]]['created_on']
                end_time = self.df.iloc[burst_indices[-1]]['created_on']
                duration = end_time - start_time
                burst_data.append({
                    'Rajada': f"#{i+1}",
                    'Alertas': len(burst_indices),
                    'In√≠cio': start_time.strftime("%d/%m/%Y %H:%M"),
                    'Fim': end_time.strftime("%d/%m/%Y %H:%M"),
                    'Dura√ß√£o': str(duration)
                })
            st.dataframe(pd.DataFrame(burst_data), use_container_width=True)

    def show_trend_analysis(self):
        st.header("üìà An√°lise de Tend√™ncias")
        daily_counts = self.df.groupby('date').size()
        if len(daily_counts) >= 7:
            fig = go.Figure()
            fig.add_trace(go.Scatter(
                x=daily_counts.index,
                y=daily_counts.values,
                mode='lines+markers',
                name='Alertas por dia',
                line=dict(color='blue')
            ))
            x_numeric = np.arange(len(daily_counts))
            slope, intercept, r_value, p_value, std_err = stats.linregress(x_numeric, daily_counts.values)
            trend_line = slope * x_numeric + intercept
            fig.add_trace(go.Scatter(
                x=daily_counts.index,
                y=trend_line,
                mode='lines',
                name='Tend√™ncia',
                line=dict(color='red', dash='dash')
            ))
            fig.update_layout(
                title="üìä Evolu√ß√£o Temporal dos Alertas",
                xaxis_title="Data",
                yaxis_title="N√∫mero de Alertas",
                hovermode='x'
            )
            st.plotly_chart(fig, use_container_width=True)
            if slope > 0.01:
                trend = "CRESCENTE üìà"
            elif slope < -0.01:
                trend = "DECRESCENTE üìâ"
            else:
                trend = "EST√ÅVEL ‚û°Ô∏è"
            strength = "FORTE" if abs(r_value) > 0.7 else "MODERADA" if abs(r_value) > 0.3 else "FRACA"
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                st.metric("üéØ Tend√™ncia", trend)
            with col2:
                st.metric("üí™ For√ßa", strength)
            with col3:
                st.metric("üìä Correla√ß√£o", f"{r_value:.4f}")
            with col4:
                st.metric("‚ö° Taxa/dia", f"{slope:.4f}")
        else:
            st.warning("‚ö†Ô∏è Poucos dados para an√°lise de tend√™ncia (m√≠nimo 7 dias)")

    def show_anomaly_detection(self):
        st.header("üö® Detec√ß√£o de Anomalias")
        intervals = self.df['time_diff_hours'].dropna()
        if len(intervals) > 4:
            Q1 = intervals.quantile(0.25)
            Q3 = intervals.quantile(0.75)
            IQR = Q3 - Q1
            lower_bound = Q1 - 1.5 * IQR
            upper_bound = Q3 + 1.5 * IQR
            fast_anomalies = intervals[intervals < lower_bound]
            slow_anomalies = intervals[intervals > upper_bound]
            normal_intervals = intervals[(intervals >= lower_bound) & (intervals <= upper_bound)]
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("‚ö° Intervalos Curtos", len(fast_anomalies))
            with col2:
                st.metric("üêå Intervalos Longos", len(slow_anomalies))
            with col3:
                st.metric("‚úÖ Intervalos Normais", len(normal_intervals))
            fig = go.Figure()
            fig.add_trace(go.Box(
                y=intervals,
                name="Intervalos (horas)",
                boxpoints='outliers'
            ))
            fig.update_layout(
                title="üìä Distribui√ß√£o dos Intervalos (Detec√ß√£o de Outliers)",
                yaxis_title="Horas"
            )
            st.plotly_chart(fig, use_container_width=True)
            if len(fast_anomalies) > 0 or len(slow_anomalies) > 0:
                col1, col2 = st.columns(2)
                with col1:
                    if len(fast_anomalies) > 0:
                        st.subheader("‚ö° Intervalos Muito Curtos")
                        st.write(f"Menor intervalo: **{fast_anomalies.min():.2f} horas**")
                        st.write(f"M√©dia dos curtos: **{fast_anomalies.mean():.2f} horas**")
                with col2:
                    if len(slow_anomalies) > 0:
                        st.subheader("üêå Intervalos Muito Longos")
                        st.write(f"Maior intervalo: **{slow_anomalies.max():.2f} horas**")
                        st.write(f"M√©dia dos longos: **{slow_anomalies.mean():.2f} horas**")
        else:
            st.warning("‚ö†Ô∏è Poucos dados para detec√ß√£o de anomalias")

    def show_predictions(self):
        st.header("üîÆ Insights Preditivos")
        col1, col2 = st.columns(2)
        with col1:
            st.subheader("‚è∞ Hor√°rios de Maior Probabilidade")
            hourly_prob = self.df['hour'].value_counts(normalize=True).sort_values(ascending=False)
            prob_data = [{'Hor√°rio': f"{hour:02d}:00", 'Probabilidade': f"{prob*100:.1f}%"} for hour, prob in hourly_prob.head(5).items()]
            st.dataframe(pd.DataFrame(prob_data), use_container_width=True)
        with col2:
            st.subheader("üìÖ Dias de Maior Probabilidade")
            daily_prob = self.df['day_name'].value_counts(normalize=True).sort_values(ascending=False)
            day_data = [{'Dia': day, 'Probabilidade': f"{prob*100:.1f}%"} for day, prob in daily_prob.items()]
            st.dataframe(pd.DataFrame(day_data), use_container_width=True)
        st.subheader("‚è±Ô∏è Previs√£o do Pr√≥ximo Alerta")
        intervals = self.df['time_diff_hours'].dropna()
        if len(intervals) > 0:
            avg_interval = intervals.mean()
            median_interval = intervals.median()
            last_alert = self.dates.max()
            next_avg = last_alert + timedelta(hours=avg_interval)
            next_median = last_alert + timedelta(hours=median_interval)
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("üïê √öltimo Alerta", last_alert.strftime("%d/%m %H:%M"))
            with col2:
                st.metric("üìä Pr√≥ximo (M√©dia)", next_avg.strftime("%d/%m %H:%M"))
            with col3:
                st.metric("üìà Pr√≥ximo (Mediana)", next_median.strftime("%d/%m %H:%M"))
            st.info(f"üí° **Baseado em:** Intervalo m√©dio de {avg_interval:.1f}h e mediana de {median_interval:.1f}h")

def main():
    st.title("üö® Analisador de Alertas - Vers√£o Completa")
    st.markdown("### An√°lise individual, global e agrupamento inteligente de alertas")
    st.sidebar.header("‚öôÔ∏è Configura√ß√µes")
    analysis_mode = st.sidebar.selectbox(
        "üéØ Modo de An√°lise",
        ["üåç An√°lise Global", "üîç An√°lise Individual"],
        help="Escolha entre analisar todos os alertas ou um alerta espec√≠fico"
    )
    uploaded_file = st.sidebar.file_uploader(
        "üìÅ Upload do arquivo CSV",
        type=['csv'],
        help="Fa√ßa upload do arquivo CSV contendo os dados dos alertas"
    )
    if uploaded_file is not None:
        analyzer = StreamlitAlertAnalyzer()
        if analyzer.load_data(uploaded_file):
            if analysis_mode == "üåç An√°lise Global":
                st.markdown("---")
                use_multiprocessing = st.sidebar.checkbox(
                    "‚ö° Usar Multiprocessing (Mais R√°pido)", 
                    value=True,
                    help="Processa alertas em paralelo para melhor desempenho"
                )
                if st.sidebar.button("üöÄ Executar An√°lise Global", type="primary"):
                    if analyzer.prepare_global_analysis(use_multiprocessing):
                        tab1, tab2, tab3, tab4 = st.tabs([
                            "üìä Vis√£o Geral",
                            "üéØ Agrupamento", 
                            "üë• Perfis dos Clusters",
                            "üí° Recomenda√ß√µes"
                        ])
                        with tab1:
                            analyzer.show_global_overview()
                        with tab2:
                            n_clusters = analyzer.perform_clustering_analysis()
                        with tab3:
                            analyzer.show_cluster_profiles(n_clusters)
                        with tab4:
                            analyzer.show_cluster_recommendations()
                        st.sidebar.markdown("---")
                        st.sidebar.subheader("üì• Downloads")
                        csv_buffer = io.StringIO()
                        analyzer.df_all_alerts.to_csv(csv_buffer, index=False)
                        st.sidebar.download_button(
                            label="‚¨áÔ∏è Baixar An√°lise Global",
                            data=csv_buffer.getvalue(),
                            file_name=f"analise_global_{datetime.now().strftime('%Y%m%d_%H%M')}.csv",
                            mime="text/csv"
                        )
                    else:
                        st.error("‚ùå N√£o foi poss√≠vel processar os dados para an√°lise global")
            else:
                try:
                    unique_ids = analyzer.df_original['u_alert_id'].unique()
                    selected_id = st.sidebar.selectbox(
                        "üéØ Selecione o Alert ID",
                        unique_ids,
                        help="Escolha o ID do alerta para an√°lise"
                    )
                    if st.sidebar.button("üöÄ Executar An√°lise Individual", type="primary"):
                        if analyzer.prepare_individual_analysis(selected_id):
                            st.success(f"üéØ Analisando alert_id: {selected_id} ({len(analyzer.df)} registros)")
                            st.info(f"üìÖ **Per√≠odo analisado:** {analyzer.dates.min()} at√© {analyzer.dates.max()}")
                            tab1, tab2, tab3, tab4, tab5, tab6, tab7 = st.tabs([
                                "üîç Isolados vs Cont√≠nuos",
                                "üìä B√°sico", 
                                "‚è∞ Temporais", 
                                "üí• Rajadas", 
                                "üìà Tend√™ncias", 
                                "üö® Anomalias", 
                                "üîÆ Previs√µes"
                            ])
                            with tab1:
                                analyzer.show_individual_alert_analysis()
                            with tab2:
                                analyzer.show_basic_stats()
                            with tab3:
                                analyzer.show_temporal_patterns()
                            with tab4:
                                analyzer.show_burst_analysis()
                            with tab5:
                                analyzer.show_trend_analysis()
                            with tab6:
                                analyzer.show_anomaly_detection()
                            with tab7:
                                analyzer.show_predictions()
                            st.sidebar.markdown("---")
                            st.sidebar.subheader("üì• Download")
                            csv_buffer = io.StringIO()
                            analyzer.df.to_csv(csv_buffer, index=False)
                            st.sidebar.download_button(
                                label="‚¨áÔ∏è Baixar Dados Processados",
                                data=csv_buffer.getvalue(),
                                file_name=f"analise_{selected_id}_{datetime.now().strftime('%Y%m%d_%H%M')}.csv",
                                mime="text/csv"
                            )
                        else:
                            st.error(f"‚ùå Nenhum registro encontrado para alert_id: {selected_id}")
                except Exception as e:
                    st.error(f"‚ùå Erro ao processar an√°lise individual: {e}")
    else:
        st.info("üëÜ Fa√ßa upload de um arquivo CSV para come√ßar a an√°lise")
        with st.expander("üìñ Instru√ß√µes de Uso"):
            st.markdown("""
            ### Como usar este analisador:
            #### üåç **An√°lise Global**
            1. **üìÅ Upload do arquivo:** Carregue um arquivo CSV com os dados dos alertas
            2. **üéØ Selecione "An√°lise Global"** no modo de an√°lise
            3. **‚ö° Ative Multiprocessing** para processamento mais r√°pido (recomendado)
            4. **üöÄ Clique em "Executar An√°lise Global"**
            5. **üìä Explore os resultados** nas diferentes abas
            #### üîç **An√°lise Individual**
            1. **üìÅ Upload do arquivo:** Carregue um arquivo CSV com os dados dos alertas
            2. **üéØ Selecione "An√°lise Individual"** no modo de an√°lise
            3. **üéØ Escolha um Alert ID** espec√≠fico
            4. **üöÄ Clique em "Executar An√°lise Individual"**
            5. **üìä Navegue pelas abas** para ver diferentes an√°lises detalhadas
            ### Colunas necess√°rias no CSV:
            - `u_alert_id`: Identificador √∫nico do alerta
            - `created_on`: Data e hora da cria√ß√£o do alerta
            ### üöÄ **Novo: Multiprocessing!**
            - **‚ö° Processamento Paralelo:** Usa m√∫ltiplos n√∫cleos da CPU
            - **üìà Muito mais r√°pido:** Ideal para grandes volumes de dados
            - **üîß Autom√°tico:** Detecta n√∫mero ideal de processos
            - **üíæ Fallback seguro:** Volta para modo sequencial se houver problemas
            """)

if __name__ == "__main__":
    main()
